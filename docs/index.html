<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ObjectValidation | ObjectValidation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ObjectValidation | ObjectValidation ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="objectvalidation">ObjectValidation</h1>

<p>This library contains some object validation helper:</p>
<ul>
<li><code>(Try)ValidateObject</code> extension for validating any object type</li>
<li><code>NoValidationAttribute</code> for excluding types or properties from validation</li>
<li><code>ObjectValidationException</code> for handling validation errors</li>
<li>Validation events</li>
<li><code>CountLimitAttribute</code> for limiting dictionary, list, array, collection and
enumerable lengths</li>
<li><code>ValidatableObjectBase</code> for implementing automatic validated types</li>
<li>Deep dictionary and list key/value validation</li>
<li><code>ICountable</code> and <code>ILongCountable</code> interfaces for count limitation</li>
<li><code>ItemNullableAttribute</code> for (non-)nullable dictionary or list item validation</li>
<li>SWIFT validation attributes for ISO 13616 IBAN and ISO 9362 BIC (SWIFT codes)</li>
<li>ABA RTN validation attributes (MICR and fraction formats are supported)</li>
<li>IP address validation attribute for IPv4 and IPv6</li>
<li>Country ISO 3166-1 alpha-2 code validation</li>
<li>Currency ISO 4217 code validation</li>
<li>Money amount validation</li>
<li>Luhn checksum validation</li>
<li>XRechnung routing validation</li>
<li>European VAT ID validation</li>
<li>XML validation</li>
<li>Conditional value requirements</li>
<li>Enumeration value validation</li>
<li>Validation references</li>
<li>Validation templates (also conditional)</li>
</ul>
<p>It has been developed with the goal to offer an automatted deep object
validation with support for deep dictionaries and lists contents, too.</p>
<p>All public instance properties with a public getter method will be validated,
unless there's a <code>NoValidationAttribute</code> present. You can use any
<code>ValidationAttribute</code> to define property value constraints.</p>
<p>Also the <code>IValidatableObjectBase</code> interface is supported by using the
<code>Validator.TryValidateObject</code> method with the <code>validateAllProperties</code>
parameter having the value <code>true</code> (the <code>IValidationObject</code> validation method
will be called in a second round). Using this interface you can implement some
more advanced custom validations, if required.</p>
<p><strong>NOTE</strong>: The ObjectValidation doesn't replace the classic built in .NET
object validation - it extends the existing routines with deep validation and
more. Btw. you don't need to use the ObjectValidation methods, if you only
want to profit from the included general validation attributes for SWIFT etc.</p>
<h2 id="how-to-get-it">How to get it</h2>
<p>The libraries are available as NuGet packages:</p>
<ul>
<li><a href="https://www.nuget.org/packages/ObjectValidation/">ObjectValidation</a></li>
<li><a href="https://www.nuget.org/packages/ObjectValidation-CountryValidator/">ObjectValidation-CountryValidator</a></li>
</ul>
<h2 id="license">License</h2>
<p>The <strong>ObjectValidation</strong> is licensed using the <strong>MIT license</strong>.</p>
<p>The <strong>ObjectValidation-CountryValidator</strong> extension is licensed using the
<strong>Apache-2.0 license</strong>.</p>
<h2 id="additional-validations">Additional validations</h2>
<table>
<thead>
<tr>
<th>Validation</th>
<th>Attribute</th>
</tr>
</thead>
<tbody>
<tr>
<td>Validations by event handlers</td>
<td>(see <code>ValidationExtensions</code>)</td>
</tr>
<tr>
<td>Dictionary list and enumerable count limit</td>
<td><code>CountLimitAttribute</code></td>
</tr>
<tr>
<td>Nullable types (<code>null</code> values in non-nullable properties will fail)</td>
<td><code>NullableAttribute</code></td>
</tr>
<tr>
<td>Dictionary and list key/value validation (including validating (non-)null items</td>
<td><code>ItemNullableAttribute</code></td>
</tr>
<tr>
<td>ISO 13616 IBAN and ISO 9362 BIC (SWIFT code) validation</td>
<td><code>IbanAttribute</code>, <code>BicAttribute</code></td>
</tr>
<tr>
<td>ABA RTN validation (MICR/fraction) validation</td>
<td><code>AbaRtnAttribute</code></td>
</tr>
<tr>
<td>IP address validation</td>
<td><code>IpAttribute</code></td>
</tr>
<tr>
<td>Country ISO 3166-1 alpha-2 code validation</td>
<td><code>CountryAttribute</code></td>
</tr>
<tr>
<td>Currency ISO 4217 code validation</td>
<td><code>CurrencyAttribute</code></td>
</tr>
<tr>
<td>Money amount validation</td>
<td><code>AmountAttribute</code></td>
</tr>
<tr>
<td>Luhn checksum validation</td>
<td><code>LuhnChecksumAttribute</code></td>
</tr>
<tr>
<td>XRechnung routing validation</td>
<td><code>XRechnungRouteAttribute</code></td>
</tr>
<tr>
<td>European VAT ID validation</td>
<td><code>EuVatIdAttribute</code></td>
</tr>
<tr>
<td>XML validation</td>
<td><code>XmlAttribute</code></td>
</tr>
<tr>
<td>Conditional value requirement</td>
<td><code>RequiredIfAttribute</code></td>
</tr>
<tr>
<td>Allowed/denied values</td>
<td><code>AllowedValuesAttribute</code>, <code>DeniedValuesAttribute</code></td>
</tr>
<tr>
<td>Enumeration value</td>
<td>(none - using the type)</td>
</tr>
<tr>
<td>Validation references</td>
<td><code>ValidationReferenceAttribute</code></td>
</tr>
<tr>
<td>Validation templates</td>
<td><code>ValidationTemplateAttribute</code>, <code>ValidationTemplateIfAttribute</code></td>
</tr>
</tbody>
</table>
<h2 id="deep-object-validation">Deep object validation</h2>
<p>Nested property object value validation is supported for:</p>
<ul>
<li>Dictionaries</li>
<li>Lists</li>
<li>Arrays</li>
<li>Collections</li>
<li>Enumerables</li>
<li>Any non-value types</li>
</ul>
<h2 id="lengthcount-validation">Length/count validation</h2>
<p>The length/count of dictionaries, lists, arrays and enumerables can be
validated using the <code>CountLimitAttribute</code> (which may not work for enumerables,
if not used trough ObjectValidation methods!).</p>
<h3 id="limiting-countables">Limiting countables</h3>
<p>By implementing the <code>ICountable</code> or <code>ILongCountable</code> interfaces you can use
the <code>CountLimitAttribute</code> for limiting the minimum/maximum count of an object.</p>
<h2 id="null-values"><code>null</code> values</h2>
<p>The object validation will generate an error, if a non-null property has a
<code>null</code> value (or any non-null-expected value is <code>null</code>).</p>
<pre><code class="lang-cs">public string StringProperty { get; set; } = null!// This will generate an error
</code></pre>
<p>If a non-null property was initialized with <code>null</code>, and the code forgot to set
another value, the ObjectValidation will create an error for this property.</p>
<p>Another feature is the validation of (non-)null dictionary or list items:</p>
<pre><code class="lang-cs">[ItemNullable]
public List&lt;string?&gt; NullableList { get; set; } = new() { null };// Ok

[ItemNullable]
public List&lt;string&gt; NonNullList { get; set; } = new() { null! };// Ok

public List&lt;string?&gt; NullableList2 { get; set; } = new() { null };// This will generate an error

public List&lt;string&gt; NonNullList2 { get; set; } = new() { null! };// This will generate an error
</code></pre>
<p>Using the <code>ItemNullableAttribute</code> you can define, if the dictionary value or
the list item may be <code>null</code>.</p>
<h2 id="general-examples">General examples</h2>
<pre><code class="lang-cs">// Only determine if valid/invalid
if(!anyObject1.TryValidateObject())
{
    // Object invalid
}

// Get validation messages in a new list
if(!anyObject2.TryValidateObject(out List&lt;ValidationResult&gt; results))
{
    // Object invalid
}

// Get validation messages in an existing list
results.Clear();
if(!anyObject3.TryValidateObject(results)) 
{
    // Object invalid
}

// Check for exceptions during validation
if(results.HasValidationException())
{
    Console.WriteLine(results.First(r =&gt; r.ErrorMessage?.StartsWith(ValidationExtensions.VALIDATION_EXCEPTION_PREFIX)).ErrorMessage);
}

// Fluent syntax without the &quot;Try&quot; method name prefix (will throw a ObjectValidationException on error)
return anyObject4.ValidateObject();
</code></pre>
<p><strong>NOTE</strong>: Any <code>ValidationResult</code> will let the validation fail in total!</p>
<p>In case you want to forward error messages to a peer, you may want to exclude
exceptions and their stack trace. You can use the <code>HasValidationException</code>
method and a LINQ expression like the one from the example to filter out any
exception in the results.</p>
<p><code>ValidatableObjectBase</code> types may be validated automatic (depending on the app
context), because they implement the <code>IValidatableObject</code> interface. The
<code>ValidatableObjectBase</code> executes the ObjectValidation method internal. For
using the <code>ValidatableObject</code> base class, simply extend from it, and call the
base constructor from your constructor methods.</p>
<p><strong>TIP</strong>: You should use the <code>ValidatableObject</code> base type, if possible! By
only implementing the <code>IValidatableObject</code> interface your type may be
validated automatic, but not by the ObjectValidation library!</p>
<p>In case you can't extend from <code>ValidatableObjectBase</code>, you can implement the
<code>IValidatableObject</code> and <code>IObjectValidatable</code> interfaces like this:</p>
<pre><code class="lang-cs">public class YourType : AnyBaseType, IObjectValidatable
{
    ...

    // Implement IValidatableObject
    IEnumerable&lt;ValidationResult&gt; IValidatableObject.Validate(ValidationContext context)
        =&gt; ValidatableObject.ObjectValidatable(this);
}
</code></pre>
<h2 id="conditional-value-requirement">Conditional value requirement</h2>
<p>If a property value is required in case another property has a specified value:</p>
<pre><code class="lang-cs">[Bic]
public string BIC { get; set; } = null!;

[Iban, RequiredIf(nameof(ABA), RequiredIfNull = true)]
public string? IBAN { get; set; }

[AbaRtn, RequiredIf(nameof(IBAN), RequiredIfNull = true)]
public string? ABA { get; set; }
</code></pre>
<p>In this example, a BIC is required in combination with an IBAN or an ABA RTN.
The <code>RequiredIfAttribute.RequiredIfNull</code> is set to <code>true</code> to check for IBAN
and ABA, if the other property value is <code>null</code>: In case ABA is <code>null</code>, IBAN is
required. In case IBAN is <code>null</code>, ABA is required.</p>
<p>Another example:</p>
<pre><code class="lang-cs">public bool DeliveryAddress { get; set; }

[RequiredIf(nameof(DeliveryAddress), true)]
public string? DeliveryName { get; set; }

[RequiredIf(nameof(DeliveryAddress), true)]
public string? DeliveryStreet { get; set; }

[RequiredIf(nameof(DeliveryAddress), true)]
public string? DeliveryZip { get; set; }

[RequiredIf(nameof(DeliveryAddress), true)]
public string? DeliveryCity { get; set; }

[RequiredIf(nameof(DeliveryAddress), true), Country]
public string? DeliveryCountry { get; set; }
</code></pre>
<p>In case the value of <code>DeliveryAddress</code> is <code>true</code>, all delivery address
properties are required to have a value.</p>
<p><strong>NOTE</strong>: Because the validation attribute needs to access the validated
object properties, it's required to work with valid validation contexts, which
contain the validated object instance.</p>
<h2 id="dictionary-and-list-keyvalue-validation">Dictionary and list key/value validation</h2>
<p>By implementing the <code>IItemValidationAttribute</code> interface, you can define
validation attributes that are going to be applied on each key/value of a
dictionary or a list. There's an almost generic <code>ItemValidationAttribute</code>
which allows to construct with any <code>ValidationAttribute</code>. For the .NET built
in validation attributes (most of them) there are adapting attributes, which
start with <code>Item</code> and continue with the original attribute name. By setting a
<code>target</code> in the <code>ItemValidationAttribute</code> constructor, you can define, if a
validation should only be applied to a dictionary key. Examples:</p>
<pre><code class="lang-cs">[CountLimit(1, 10)]// Dictionary object validation
[ItemRequired(ItemValidationTarget.Key), ItemStringLength(100, ItemValidationTarget.Key)]// Key validation
[ItemRequired, ItemStringLength(255)]// Value validation
public Dictionary&lt;string, string&gt; Dict { get; }

[CountLimit(1, 10)]// List object validation
[ItemRequired, ItemStringLength(255)]// Item validation
public List&lt;string&gt; List { get; }
</code></pre>
<p>The dictionary needs to have at last one, maximum 10 key/value pairs, where
the key length needs to be between 1-100 characters, and the value length
needs to be 1-255 characters.</p>
<p>The list needs to have at last one, maximum 10 items, where each item length
is limited to 1-255 characters.</p>
<p>Using the <code>ItemNoValidationAttribute</code> you can disable key/value validation for
a property. In case of an enumerable value, the enumeration needs to be
executed in case there's a <code>CountLimitAttribute</code> present.</p>
<p>These item validation adapters exist:</p>
<table>
<thead>
<tr>
<th>Property validation</th>
<th>Item validation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ValidationAttribute</code></td>
<td><code>ItemValidationAttribute</code></td>
</tr>
<tr>
<td><code>CountLimitAttribute</code></td>
<td><code>ItemCountLimitAttribute</code></td>
</tr>
<tr>
<td><code>RequiredAttribute</code></td>
<td><code>ItemRequiredAttribute</code></td>
</tr>
<tr>
<td><code>CompareAttribute</code></td>
<td><code>ItemCompareAttribute</code></td>
</tr>
<tr>
<td><code>CreditCardAttribute</code></td>
<td><code>ItemCreditCardAttribute</code></td>
</tr>
<tr>
<td><code>EmailAddressAttribute</code></td>
<td><code>ItemEmailAddressAttribute</code></td>
</tr>
<tr>
<td><code>MaxLengthAttribute</code></td>
<td><code>ItemMaxLengthAttribute</code></td>
</tr>
<tr>
<td><code>MinLengthAttribute</code></td>
<td><code>ItemMinLengthAttribute</code></td>
</tr>
<tr>
<td><code>NoValidationAttribute</code></td>
<td><code>ItemNoValidationAttribute</code></td>
</tr>
<tr>
<td><code>PhoneAttribute</code></td>
<td><code>ItemPhoneAttribute</code></td>
</tr>
<tr>
<td><code>RangeAttribute</code></td>
<td><code>ItemRangeAttribute</code></td>
</tr>
<tr>
<td><code>RegularExpressionAttribute</code></td>
<td><code>ItemRegularExpressionAttribute</code></td>
</tr>
<tr>
<td><code>StringLengthAttribute</code></td>
<td><code>ItemStringLengthAttribute</code></td>
</tr>
<tr>
<td><code>UrlAttribute</code></td>
<td><code>ItemUrlAttribute</code></td>
</tr>
<tr>
<td><code>DataTypeAttribute</code></td>
<td><code>ItemDataTypeAttribute</code></td>
</tr>
<tr>
<td><code>IbanAttribute</code></td>
<td><code>ItemIbanAttribute</code></td>
</tr>
<tr>
<td><code>BicAttribute</code></td>
<td><code>ItemBicAttribute</code></td>
</tr>
<tr>
<td><code>AbaRtnAttribute</code></td>
<td><code>ItemAbaRtnAttribute</code></td>
</tr>
<tr>
<td><code>IpAttribute</code></td>
<td><code>ItemIpAttribute</code></td>
</tr>
<tr>
<td><code>CountryAttribute</code></td>
<td><code>ItemCountryAttribute</code></td>
</tr>
<tr>
<td><code>CurrencyAttribute</code></td>
<td><code>ItemCurrencyAttribute</code></td>
</tr>
<tr>
<td><code>AmountAttribute</code></td>
<td><code>ItemAmountAttribute</code></td>
</tr>
<tr>
<td><code>LuhnChecksumAttribute</code></td>
<td><code>ItemLuhnChecksumAttribute</code></td>
</tr>
<tr>
<td><code>XRechnungRouteAttribute</code></td>
<td><code>ItemXRechnungRouteAttribute</code></td>
</tr>
<tr>
<td><code>EuVatIdAttribute</code></td>
<td><code>ItemEuVatIdAttribute</code></td>
</tr>
<tr>
<td><code>AllowedValuesAttribute</code></td>
<td><code>ItemAllowedValuesAttribute</code></td>
</tr>
<tr>
<td><code>DeniedValuesAttribute</code></td>
<td><code>ItemDeniedValuesAttribute</code></td>
</tr>
<tr>
<td><code>CustomValidationAttribute</code></td>
<td><code>ItemCustomValidationAttribute</code></td>
</tr>
<tr>
<td><code>ValidationReferenceAttribute</code></td>
<td><code>ItemValidationReferenceAttribute</code></td>
</tr>
<tr>
<td><code>ValidationReferenceIfAttribute</code></td>
<td><code>ItemValidationReferenceIfAttribute</code></td>
</tr>
<tr>
<td><code>ValidationTemplateAttribute</code></td>
<td><code>ItemValidationTemplateAttribute</code></td>
</tr>
<tr>
<td><code>ValidationTemplateIfAttribute</code></td>
<td><code>ItemValidationTemplateIfAttribute</code></td>
</tr>
</tbody>
</table>
<p>You can use the <code>ItemNoValidationAttribute</code> at the class level to prevent from
validating and dictionary or list contents.</p>
<p><strong>NOTE</strong>: By setting the <code>ArrayLevel</code> (starts with zero) of an
<code>ItemValidationAttribute</code>, you can specify to use the item for the desired
array level only. This enables array of array etc. item validations. Entering
a deeper array level counts as recursion. The array level can be set for
dictionary keys, too, if they're a dictionary or a list.</p>
<p>Use the <code>ItemNullableAttribute</code>, if the dictionary value or list item may be
<code>null</code> (even if you wrote <code>T?</code> in your code, because the nullability
information may not be available during validation!).</p>
<h2 id="enumeration-value-validation">Enumeration value validation</h2>
<p>An enumeration can be a value list or combined flags. Both variants are
validated by checking if</p>
<ul>
<li>the value contains undefined flags</li>
<li>the value is an undefined enumeration value</li>
</ul>
<p>This ensures, that only defined enumeration (flag) values can be used.</p>
<h2 id="validation-references">Validation references</h2>
<p>Using a validation reference attribute you can inherit validation attributes
from another property, and even from another type:</p>
<pre><code class="lang-cs">public class A
{
    [StringLength(3)]
    public string Property { get; set; } = string.Empty;
}

public class B
{
    [ValidationReference(typeof(A), nameof(A.Property))]
    public string Property { get; set; } = string.Empty;
}

B obj = new()
{
    Property = &quot;1234&quot;
};
obj.ValidateObject();// Will fail, 'cause A.Property limits the string length to 3 characters
</code></pre>
<p>Now <code>B.Property</code> uses the validation attributes from <code>A.Property</code>.</p>
<p><strong>CAUTION</strong>: Attributes which would skip property/item validation will be
ignored!</p>
<p><strong>NOTE</strong>: The validation will fail with the first validation result of an
attribute from the target property.</p>
<h2 id="validation-templates">Validation templates</h2>
<p>Similar to validation references you can use validation templates, which are
not bound to another existing property, but managed in the
<code>ValidationTemplates</code> class:</p>
<pre><code class="lang-cs">// Define a property validation template
ValidationTemplates.PropertyValidations[&quot;Template name&quot;] = new()
{
    new StringLengthAttribute(3)
};

// Apply the template
public class YourType
{
    [ValidationTemplate(&quot;Template name&quot;)]
    public string Property { get; set; } = string.Empty;
}

YourType obj = new()
{
    Property = &quot;1234&quot;
};
obj.ValidateObject();// Will fail, 'cause the validation template limits the string length to 3 characters
</code></pre>
<p>The same is also available for item validation, using the
<code>ValidationTemplates.ItemValidations</code> store, and the
<code>ItemValidationTemplateAttribute</code>.</p>
<p><strong>CAUTION</strong>: Attributes which would skip property/item validation will be
ignored!</p>
<p><strong>NOTE</strong>: The validation will fail with the first validation result of an
attribute from the template, if not validated using the ObjectValidation
methods.</p>
<p>The <code>ValidationTemplateIfAttribute</code> allows to apply a template only in case a
condition was met (just as with the <code>RequiredIfAttribute</code>).</p>
<h2 id="deny-and-force-type-validation">Deny and force type validation</h2>
<p>Using the <code>ValidatableTypes</code> class you can define types which are not
validated, or which are forced to be vlidated, in addition to the default type
filter, which doesn't validate a type if</p>
<ul>
<li>it's a non-enum value type</li>
<li>it's an array</li>
<li>the type was marked with a <code>NoValidationAttribute</code> attribute</li>
</ul>
<p>A denied type can't be forced to be validated.</p>
<p>You can add a generic type definition for generic (final) types, and also
abstract types or interfaces. Anyway, when determining if a type should be
validated, its generic type definition (if the given type is generic) will
be checked, too - but not inherited (maybe abstract) types or interfaces.</p>
<p>Per default these types won't be validated:</p>
<ul>
<li><code>string</code></li>
<li><code>object</code></li>
<li><code>IQueryable&lt;&gt;</code></li>
</ul>
<p><strong>NOTE</strong>: <code>string</code> and <code>object</code> shouldn't be removed from the denied type
list!</p>
<p>By attaching to the <code>ValidatableTypes.OnIsTypeValidatable</code>, you can make a
conditional exception for an usually not validated type.</p>
<h2 id="force-to-fail-with-an-exception">Force to fail with an exception</h2>
<p>If you set the parameter <code>throwOnError</code> value to <code>true</code>, the validation will
throw a <code>ObjectValidationException</code>, as soon as an object was invalidated.</p>
<h2 id="validation-of-a-property-group">Validation of a property group</h2>
<p>By giving a list of member names to validate as <code>members</code> parameter, you can
avoid validating all properties which could be validated (f.e. you could
validate only a property group).</p>
<h2 id="handling-validation-events">Handling validation events</h2>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OnObjectValidation</code></td>
<td>You can perform validations before any other validations have been executed. When the event was cancelled, there won't be any following validation, and the produced result will be used.</td>
</tr>
<tr>
<td><code>OnObjectValidationFailed</code></td>
<td>Raised, if the object validation failed. You may add additional error messages, before the validation method returns.</td>
</tr>
<tr>
<td><code>OnObjectPropertyValidation</code></td>
<td>You can perform validations before any other validations have been executed for the property. When the event was cancelled, there won't be any following validation, and the produced result will be used for the current property. The validation will then continue with the next property.</td>
</tr>
<tr>
<td><code>OnObjectPropertyValidationFailed</code></td>
<td>Raised, if the object validation failed. You may add additional error messages, before the validation method continues with the next property. When the event was cancelled, the following property validations will be skipped.</td>
</tr>
</tbody>
</table>
<p>If the event arguments don't offer a <code>PropertyInfo</code> in the <code>Property</code>
property, the event was raised for the validated object.</p>
<p>An event handler can set a failed state by setting the <code>Result</code> property of
the event arguments to <code>false</code>.</p>
<p><strong>WARNING</strong>: Do not set the value <code>true</code> to the <code>Result</code> property! An already
failed state can't be deleted, unless the original result <code>OriginalResult</code> was
<code>true</code>.</p>
<p>The object validation will fail, if there was any validation result, or the
overall result is <code>false</code>.</p>
<h2 id="object-validation-methods">Object validation methods</h2>
<p>In addition to the .NET object validation methods you can validate objects
like this:</p>
<pre><code class="lang-cs">// Will throw an exception on error
try
{
    obj.ValidateObject(out List&lt;ValidationResult&gt; results);
}
catch(ObjectValidationException ex)
{
    // Handle the object errors
}

// Won't throw an exception
if(!obj.TryValidateObject(out List&lt;ValidationResult&gt; results))
{
    // Handle the object errors
}

// Will execute an error handler (which may throw, f.e.)
bool valid = obj.EnsureValidObject((obj, results) =&gt; ...);

// The handler may correct object validation errors (or throw, f.e.) and return a valid object
obj = obj.GetValidObject((obj, results) =&gt; ...);
</code></pre>
<p>For nullable objects you can use the static methods from <code>ValidateObject</code>.</p>
<h2 id="logging">Logging</h2>
<p>If you set a log delegate to <code>ValidateObject.Logger</code>, you can log all object
validation errors:</p>
<pre><code class="lang-cs">ValidateObject.Logger = (message) =&gt; ...;
</code></pre>
<p>Per default messages will be logged to the attached debugger.</p>
<h2 id="found-a-bug">Found a bug?</h2>
<p>If the object validation doesn't work for you as expected, or you have any
idea for improvements, please open an issue - I'd be glad to help and make
ObjectValidation become even better! Push requests are welcome, too :)</p>
<h2 id="good-to-know">Good to know</h2>
<h3 id="recursion-protection">Recursion protection</h3>
<p>The object validation implements a recursion detection and won't end up in an
endless loop, unless you produce an endless loop within your custom
<code>IValidatableObject</code> validation implementation or the event handling.</p>
<p>You can define a maximum recursion depth in the
<code>ValidationExtensions.MaxDepth</code> property (the default is 32). If the depth
would be exceeded during an object validation, this would result in a
<code>ObjectValidationException</code>, which would be catched as a validation error
result, when not setting <code>throwOnError</code> to <code>true</code>.</p>
<p><strong>WARNING</strong>: If you disable the maximum recursion depth validation, this may
end up in a <code>StackOverflowException</code>, which will crash your application.</p>
<h3 id="maximum-number-of-error-messages">Maximum number of error messages</h3>
<p>You can limit the maximum number of returned error messages in the
<code>ValidationExtensions.MaxErrors</code> property (the default is 200). The object
validation would stop, once it was detected that the number of errors exceeds
this limit. Your validation result list will never contain more error messages
than defined in this limit.</p>
<p><strong>WARNING</strong>: Disabling the maximum number of error messages may end up in huge
object lists, which could lead to memory usage problems and finally a crash of
your application!</p>
<h3 id="aspnet">ASP.NET</h3>
<p>ASP.NET (7) automatic validates <code>IValidatableObject</code> objects when
unserializing for an API controller call. The ObjectValidation library will be
used automatic, if you've used the <code>ValidatableObjectBase</code> base class for your
types, which you want to be validated automatic. Simply use it as base class
for your DTO objects, and you don't need to care about validation anymore.</p>
<p>You should also understand the difference between <code>NoValidateAttribute</code> and
<code>NeverValidateAttribute</code>: <code>NoValidateAttribute</code> affects the ObjectValidation
validation, while <code>NeverValidateAttribute</code> affects all validations. So you can
use the <code>NoValidateAttribute</code> to skip double validation by the
ObjectValidation methods, if required.</p>
<h3 id="nullability">Nullability</h3>
<p>The nullability of properties can be determined using reflections, even if one
returns a generic type. But if f.e. the return type is a
<code>YourType : Dictionary&lt;string, string?&gt;</code>, the object validation isn't able to
determine the nullability of the second generic type argument of the base
type, because the nullability information will be discarded during your code
compilation. For the dictionary item validation please specify the
<code>ItemNullableAttribute</code> in that case. The same applies to deep array
validations.</p>
<h3 id="more-validations">More validations</h3>
<p>Have a look at the
<a href="https://github.com/anghelvalentin/CountryValidator">CountryValidator</a>
project for more validations like</p>
<ul>
<li>Social Security Numbers</li>
<li>Personal Identity Numbers</li>
<li>More VAT IDs</li>
<li>Tax IDs for individuals</li>
<li>Tax IDs for companies</li>
<li>ZIP codes</li>
</ul>
<p>for many countries.</p>
<p>The <code>ObjectValidation-CountryValidator</code> packet includes references to this
packet, and exports item validation attributes:</p>
<ul>
<li><code>ItemCompanyTINAttribute</code></li>
<li><code>ItemPersonTINAttribute</code></li>
<li><code>ItemSSNAttribute</code></li>
<li><code>ItemVATAttribute</code></li>
<li><code>ItemZipCodeAttribute</code></li>
</ul>
<p><strong>NOTE</strong>: The main ObjectValidation library includes validation for European
VAT IDs only. By using this packet, you can use VAT ID validation for many
countries around the world.</p>
<p><strong>CAUTION</strong>: Since the CountryValidator is licensed under Apache-2.0 license,
I decided to license the <code>ObjectValidation-CountryValidator</code> under the same
license:</p>
<p>Copyright 2023 Andreas Zimmermann, wan24.de</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h3 id="internal-validation-information-object">Internal validation information object</h3>
<p>An event handler can access the list of seen objects, which is used to prevent
an endless recursion. The first object of that list is an <code>IValidationInfo</code>
object, which contains some validation context information:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Seen</code></td>
<td>Seen objects list</td>
</tr>
<tr>
<td><code>CurrentDepth</code></td>
<td>Current recursion depth</td>
</tr>
<tr>
<td><code>ArrayLevel</code></td>
<td>Current array level</td>
</tr>
</tbody>
</table>
<p><strong>CAUTION</strong>: Please DO NOT remove or exchange this object!</p>
<p>Since array item validations don't call event handlers, the <code>ArrayLevel</code>
property will always be <code>0</code>.</p>
<h2 id="upcoming-changes-with-net-8">Upcoming changes with .NET 8</h2>
<p>Some object validations which I've implemented in the ObjectValidation library
are now part of the .NET 8 preview. I won't remove them in v1.x, but in v2.x,
which will target .NET 8.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/nd1012/ObjectValidation/blob/dev/src/ObjectValidation Docs/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            (c) 2023 Andreas Zimmermann, wan24.de
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
